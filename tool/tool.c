/************************************************************************************
					文件名：tool.c
					最后一次修改时间：2025/2/28
					修改内容：wending
*************************************************************************************/

#include "tool.h"

/************************************************************************************
 									数据类型
 ************************************************************************************/
const double PowerPositiveValue[25] =
{
    1,			2,			4,			8,			16,				// 0  1  2  3  4
    32,			64,			128,		256,		512,			// 5  6  7  8  9
    1024,		2048,		4096,		8192,		16384,			// 10 11 12 13 14
    32768,		65536,		131072,		262144,		524288,			// 15 16 17 18 19
    1048576,	2097152,	4194304,	8388608,	16777216		// 20 21 22 23 24
};

const double PowerNegativeValue[26] =
{
    1,						0.5,				0.25,					0.125,					0.0625,					//  0  -1  -2  -3  -4
    0.03125,				0.015625,			0.0078125,				0.00390625,				0.001953125,			// -5  -6  -7  -8  -9
    0.0009765625,			0.00048828125,		0.000244140625,			0.0001220703125,		0.00006103515625,		// -10 -11 -12 -13 -14
    0.000030517578125,		0.0000152587890625,	0.00000762939453125,	0.000003814697265625,	0.0000019073486328125,	// -15 -16 -17 -18 -19
    0.00000095367431640625,										// -20
    0.000000476837158203125,									// -21
    0.0000002384185791015625,									// -22
    0.00000011920928955078125,									// -23
    0.000000059604644775390625,									// -24
    0.0000000298023223876953125									// -25
};


/*******************************************************************
* 函数原型:float Tool_parseIEEE754(const unsigned int data)
* 函数简介:将32位的无符号整形数据按照IEEE754标准转换成float浮点型数据
* 函数参数:要转换的32位无符号数据
* 函数返回值:float浮点型数据 
*****************************************************************/
float Tool_parseIEEE754(const unsigned int data)
{
    float result = 0.0;

    unsigned char part1 = data >> 31;						//符号部分
    int part2 = ((data >> 23) & 0xFF) - 127;				//指数部分  0-255间的数据
    unsigned int part4 = (data & 0x7FFFFF) | 0x800000;		//尾数部分 - 组合 1.尾数部分
	
    for (int i = 0; i < 24; i++)
    {
        int p1 = (part4 >> (23 - i)) & 0x1;
        if (p1 == 0)							//因数为0，乘积为0，不参与本次计算
            continue;

        int power = part2 - i;					//计算幂指数

        double p2 = 0.0;
        if (power >= 0 && power < 25)			//查正值表
            p2 = PowerPositiveValue[power];
        else if (power <= 0 && power > -26)		//查负值表
            p2 = PowerNegativeValue[-power];
        else									//表外数据，计算,不影响结果的，可以直接取零
            p2 = 0;//pow(2,part2 - i);

        result += p1 * p2;
    }
    return part1 == 0 ? result : -result;
}


/*******************************************************************
* 函数原型:int Tool_floatCompare(float a, float b)
* 函数简介:将两个浮点数进行比较大小
* 函数参数:a,b两个要进行比较的浮点数
* 函数返回值:1，a > b; 
*           0, a = b;
*          -1, a < b;
*****************************************************************/
int Tool_floatCompare(float a, float b)
{
    float c = a - b;

    if(c > 0.0f)
        return 1;
    else if(c == 0.0f)
        return 0;
    else if(c < 0.0f)
        return -1;
    
    return 0;
}


/*******************************************************************
* 函数原型:int Tool_getSerialportReadBufferCount(int fd) 
* 函数简介:查看串口缓存区未读字符个数
* 函数参数:串口的文件描述符
* 函数返回值:剩余字符个数, 失败返回-1
*****************************************************************/
int Tool_getSerialportReadBufferCount(int fd) 
{
    int nBytes = 0;
    if(ioctl(fd, FIONREAD, &nBytes) == -1) 
    {
        perror("Tool_getSerialportReadBufferCount:ioctl");
        return -1;
    }
    return nBytes;
}